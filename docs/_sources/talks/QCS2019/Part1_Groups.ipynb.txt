{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 1. Constructing groups with RepLAB\n",
    "\n",
    "We demonstrate a few ways to construct groups using RepLAB. This notebook is a companion to the RepLAB talk at the [Quantum Causal Structures](http://www.cs.ox.ac.uk/conferences/QCS2019/) workshop."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We start by adding RepLAB to the path. The output below has been generated using MATLAB, but RepLAB is also compatible with recent versions of Octave (>= 4.2)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Adding RepLAB to the path\r\n",
      "warning: function /home/denis/w/replab/src/help.m shadows a core library function\r\n",
      "Adding RepLAB package to the path\r\n",
      "Loading optim package for Octave...\r\n",
      "OpenJDK 64-Bit Server VM warning: Archived non-system classes are disabled because the java.system.class.loader property is specified (value = \"org.octave.OctClassLoader\"). To use archived non-system classes, this property must be not be set\r\n",
      "Adding VPI to the path\r\n",
      "Adding MOxUnit to the path\r\n",
      "Adding embedded YALMIP to the path\r\n",
      "Adding embedded SDPT3 solver to the path\r\n",
      "Adding MOcov to the path\r\n"
     ]
    }
   ],
   "source": [
    "run ../../../replab_init.m"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Group axioms / laws\n",
    "RepLAB has knowledge of the group axioms, and can verify them using random sampling of elements. By default, 20 instances are checked for every law. Inspired by [QuickCheck](https://en.wikipedia.org/wiki/QuickCheck)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Checking associativity...\r\n",
      "Checking composeAll...\r\n",
      "Checking composeN integers...\r\n",
      "Checking composeN positive...\r\n",
      "Checking composeN zero...\r\n",
      "Checking eqv...\r\n",
      "Checking identity...\r\n",
      "Checking inverse...\r\n",
      "Checking inverse compatible with compose...\r\n"
     ]
    }
   ],
   "source": [
    "S4 = replab.S(4);\n",
    "replab.GroupLaws(S4).check"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Permutation groups\n",
    "RepLAB uses row vectors of 1-based integers as group elements, which facilitates integration with existing MATLAB code. When constructing a permutation group `replab.S(n)`, we construct an instance of `replab.FiniteGroup` that knows how to interpret those integer row vectors as permutations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sigma =\r\n",
      "\r\n",
      "   1   4   3   2\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "S4 = replab.S(4); % or replab.Permutations(4)\n",
    "pi = [3 4 1 2]; rho = [3 2 1 4];\n",
    "sigma = S4.compose(pi, rho)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "  1  1  1  1\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "pi(rho([1 2 3 4])) == sigma([1 2 3 4])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Permutation subgroups\n",
    "We can also construct subgroups of S(n) using a list of generators. Example for conditional probability distributions for two measurements settings with two outcomes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GAlice =\r\n",
      "\r\n",
      "replab.PermutationSubgroup\r\n",
      "  domainSize: 4                                \r\n",
      "    identity: [1, 2, 3, 4]                     \r\n",
      "      parent: Permutations acting on 4 elements\r\n",
      "generator(1): [3, 4, 1, 2]                     \r\n",
      "generator(2): [2, 1, 3, 4]                     \r\n",
      "generator(3): [1, 2, 4, 3]                     \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "piInput = [3 4 1 2];\n",
    "piOutput1 = [2 1 3 4];\n",
    "piOutput2 = [1 2 4 3];\n",
    "GAlice = replab.S(4).subgroup({piInput piOutput1 piOutput2})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "    8\r\n"
     ]
    }
   ],
   "source": [
    "GAlice.order"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "Indexed family of 8 elements\r\n",
      "1 = [1, 2, 3, 4]\r\n",
      "2 = [1, 2, 4, 3]\r\n",
      "3 = [2, 1, 3, 4]\r\n",
      "4 = [2, 1, 4, 3]\r\n",
      "5 = [3, 4, 1, 2]\r\n",
      "6 = [3, 4, 2, 1]\r\n",
      "7 = [4, 3, 1, 2]\r\n",
      "8 = [4, 3, 2, 1]\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "GAlice.elements"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "    8\r\n"
     ]
    }
   ],
   "source": [
    "GAlice1 = replab.S(4).subgroup({piInput piOutput1}); % test removing the last generator\n",
    "GAlice1.order"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Signed permutations\n",
    "Signed permutation groups are also supported with similar syntax."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GCHSH =\r\n",
      "\r\n",
      "replab.signed.PermutationSubgroup\r\n",
      "  domainSize: 4                                          \r\n",
      "    identity: [1, 2, 3, 4]                               \r\n",
      "      parent: Signed permutations acting on {-4..-1 1..4}\r\n",
      "generator(1): [3, 4, 1, 2]                               \r\n",
      "generator(2): [-1, -2, -3, -4]                           \r\n",
      "generator(3): [2, 1, 3, -4]                              \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "sParties = [3 4 1 2];\n",
    "sFlip = [-1 -2 -3 -4];\n",
    "sOther = [2 1 3 -4];\n",
    "GCHSH = replab.signed.Permutations(4).subgroup({sParties sFlip sOther})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "    16\r\n"
     ]
    }
   ],
   "source": [
    "GCHSH.order"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "Indexed family of 16 elements\r\n",
      " 1 = [1, 2, 3, 4]    \r\n",
      " 2 = [-2, -1, -3, 4] \r\n",
      " 3 = [1, -2, 4, 3]   \r\n",
      " 4 = [2, -1, -4, 3]  \r\n",
      " 5 = [3, 4, 1, 2]    \r\n",
      " 6 = [-4, -3, -1, 2] \r\n",
      " 7 = [3, -4, 2, 1]   \r\n",
      " 8 = [4, -3, -2, 1]  \r\n",
      " 9 = [-3, 4, -2, -1] \r\n",
      "10 = [-4, 3, 2, -1]  \r\n",
      "11 = [-3, -4, -1, -2]\r\n",
      "12 = [4, 3, 1, -2]   \r\n",
      "13 = [-1, 2, -4, -3] \r\n",
      "14 = [-2, 1, 4, -3]  \r\n",
      "15 = [-1, -2, -3, -4]\r\n",
      "16 = [2, 1, 3, -4]   \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "GCHSH.elements"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Wreath product groups\n",
    "We construct the wreath product of S(2) on S(2), representing the symetries of \"two measurement settings with two outcomes\"."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Gparty =\r\n",
      "\r\n",
      "replab.wreathproduct.OfNiceFiniteGroup\r\n",
      "           A: Permutations acting on 2 elements      \r\n",
      "           H: Permutations acting on 2 elements      \r\n",
      "           N: replab.directproduct.OfNiceFiniteGroups\r\n",
      "    identity: {[1, 2], {[1, 2], [1, 2]}}             \r\n",
      "           n: 2                                      \r\n",
      "      parent: replab.wreathproduct.OfNiceFiniteGroup \r\n",
      "         phi: replab.perm.PermutationCellAction      \r\n",
      "generator(1): {[2, 1], {[1, 2], [1, 2]}}             \r\n",
      "generator(2): {[1, 2], {[2, 1], [1, 2]}}             \r\n",
      "generator(3): {[1, 2], {[1, 2], [2, 1]}}             \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "Goutcomes = replab.S(2);\n",
    "Gsettings = replab.S(2);\n",
    "Gparty = Gsettings.wreathProduct(Goutcomes)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "Indexed family of 8 elements\r\n",
      "1 = {[1, 2], {[1, 2], [1, 2]}}\r\n",
      "2 = {[1, 2], {[1, 2], [2, 1]}}\r\n",
      "3 = {[1, 2], {[2, 1], [1, 2]}}\r\n",
      "4 = {[1, 2], {[2, 1], [2, 1]}}\r\n",
      "5 = {[2, 1], {[1, 2], [1, 2]}}\r\n",
      "6 = {[2, 1], {[1, 2], [2, 1]}}\r\n",
      "7 = {[2, 1], {[2, 1], [1, 2]}}\r\n",
      "8 = {[2, 1], {[2, 1], [2, 1]}}\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "Gparty.elements"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Octave",
   "language": "octave",
   "name": "octave"
  },
  "language_info": {
   "file_extension": ".m",
   "help_links": [
    {
     "text": "GNU Octave",
     "url": "https://www.gnu.org/software/octave/support.html"
    },
    {
     "text": "Octave Kernel",
     "url": "https://github.com/Calysto/octave_kernel"
    },
    {
     "text": "MetaKernel Magics",
     "url": "https://metakernel.readthedocs.io/en/latest/source/README.html"
    }
   ],
   "mimetype": "text/x-octave",
   "name": "octave",
   "version": "4.2.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
