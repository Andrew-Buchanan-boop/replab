classdef CodeBase1 < replab.Str
    
    properties
        packages % struct-based hash map
        subclasses % struct-based hash map with class subclasses
    end
    
    methods

        function self = CodeBase1(packages, subclasses)
            self.packages = packages;
            self.subclasses = subclasses;
        end

        function p = package(self, varargin)
            p = self.lookupPackage(varargin);
        end
        
        function names = hiddenFields(self)
            names = hiddenFields@replab.Str(self);
            names{1, end+1} = 'packages';
        end

        function [names values] = additionalFields(self)
            [names values] = additionalFields@replab.Str(self);
            fn = fieldnames(self.packages);
            for i = 1:length(fn)
                if isequal(fn{i}, 'root_')
                    nameParts = {};
                else
                    nameParts = strsplit(fn{i}, '_');
                end
                args = strjoin(cellfun(@(x) ['''' x ''''], nameParts, 'uniform', 0), ', ');
                names{1, end+1} = sprintf('package(%s)', args);
                values{1, end+1} = self.packages.(fn{i});
            end
        end
        
        function subpackageNames = subPackagesNames(self, packageNameParts)
            fn = fieldnames(self.packages);
            subpackageNames = {};
            if length(packageNameParts) == 0
                for i = 1:length(fn)
                    if all(fn{i} ~= '_')
                        subpackageNames{1, end+1} = fn{i};
                    end
                end
            else
                pn = strjoin(packageNameParts, '_');
                for i = 1:length(fn)
                    fni = fn{i};
                    if length(fni) > length(pn) && isequal(fni(1:length(pn)), pn)
                        rest = fni(length(pn)+2:end);
                        if all(rest ~= '_')
                            subpackageNames{1, end+1} = rest;
                        end
                    end
                end
            end
        end
        
        function p = lookupPackage(self, nameParts)
        % Looks for a package from its name parts
        %
        % Args:
        %   nameParts (cell row vector of charstring): Parts of the package name
        %
        % Returns:
        %   :class:`+replab.+infra.Package`: The corresponding package, or ``[]`` if not found
            fname = replab.infra.CodeBase1.fieldName(nameParts);
            if isfield(self.packages, fname)
                p = getfield(self.packages, fname);
            else
                p = [];
            end
        end
        
        function [package packageNameParts restNameParts] = lookupGreedy(self, nameParts)
        % Greedily looks up for a package from its name parts, disregarding the suffix that does not match 
        %
        % Returns `package` which matches `packageNameParts`, and `restNameParts` such that
        % ``nameParts = horzcat(packageNameParts, restNameParts)``.
        %
        % Args:
        %   nameParts (cell row vector of charstring): Parts of a fully qualified object name
        %
        % Returns
        % -------
        %   package: 
        %     :class:`+replab.+infra.Package`: The package looked up for
        %   packageNameParts:
        %     cell row vector of charstring: The maximal prefix of `nameParts` that matches a package name
        %   restNameParts:
        %     cell row vector of charstring: The tail of `nameParts` that could not be matched
            n = length(nameParts);
            for i = n:-1:0
                packageNameParts = nameParts(1:i);
                restNameParts = nameParts(i+1:n);
                package = self.lookupPackage(packageNameParts);
                if ~isempty(package)
                    return
                end
            end
            error('Should not happen: empty name parts match the root package');
        end
        
        function writeDocTests(self, doctestPath)
        % Writes the doc tests of the whole code base in the specified folder
        %
        % Args:
        %   doctestPath (charstring): Path of the doctests generated code, must exist
            names = fieldnames(self.packages);
            for i = 1:length(names)
                package = self.packages.(names{i});
                fprintf('Writing tests for package %s:\n', package.fullName);
                memberNames = fieldnames(package.members);
                for j = 1:length(memberNames)
                    fprintf('.. member %s:\n', memberNames{j});
                    replab.infra.writeDocTests(doctestPath, package.member(memberNames{j}));
                end
            end
        end
        
        function writeEnrichedSource(self, docSrcPath)
        % Writes the enriched source with the TOC elements
        %
        % Args:
        %   docSrcPath (charstring): Path of the enriched source, folder must exist, without trailing separator
            names = fieldnames(self.packages);
            for i = 1:length(names)
                package = self.packages.(names{i});
                fprintf('Writing enriched source for package %s:\n', package.fullName);
                memberNames = fieldnames(package.members);
                for j = 1:length(memberNames)
                    fprintf('.. member %s:\n', memberNames{j});
                    replab.infra.writeEnrichedSource(self, docSrcPath, package.member(memberNames{j}));
                end
            end
        end

        
    end
   
    methods (Static)
        
        
    end
    
end
