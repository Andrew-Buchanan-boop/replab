classdef NiceFiniteGroup < replab.FiniteGroup
% A nice finite group is a finite group equipped with an injective homomorphism into a permutation group
%
% The injective homomorphism is called a 'nice monomorphism' to keep up with the GAP System notation.
%
% This nice monomorphism enables the computation of a BSGS chain, and thus to transfer group operations
% to operations on permutation groups.
    
    properties (SetAccess = protected)
        niceMonomorphism % function_handle: Injective group homomorphism from this group into a permutation group
        chain % replab.bsgs1.Chain: BSGS chain describing this group
    end

    methods (Access = protected)
        
        function el = enumeratorAt(self, index)
            indices = self.chain.indicesFromIndex(index);
            el = self.chain.elementFromIndices(indices);
        end
        
        function index = enumeratorFind(self, el)
            [remaining indices] = self.chain.sift(el);
            if isempty(remaining) || ~self.isIdentity(remaining)
                ind = [];
            else
                index = self.chain.indexFromIndices(indices);
            end
        end
            
    end

    methods
        
        function self = NiceFiniteGroup(identity, generators, niceMonomorphism)
        % Constructs a nice finite group with the given properties
            self.identity = identity;
            self.generators = generators;
            imgId = self.niceMonomorphism(self.identity);
            n = length(imgId);
            S = cellfun(@(x) self.niceMonomorphism(x), self.generators);
            self.chain = replab.bsgs1.Chain.makeWithImages(n, S, self, generators);
            self.order = self.chain.order;
        end
        
        
        % CompactGroup methods
        
        function g = sampleUniformly(self)
            g = self.chain.sampleUniformly;
        end

        % FiniteGroup methods
        
        function E = computeElements(self)
            E = replab.Enumerator.lambda(self.order, ...
                                         @(ind) self.enumeratorAt(ind), ...
                                         @(el) self.enumeratorFind(el));
        end

        function D = computeDecomposition(self)
            D = replab.FiniteGroupDecomposition(self, self.chain.groupDecomposition);
        end
        
        % Methods enabled by the BSGS algorithms
        
        function b = contains(self, g)
        % Tests whether this group contains the given parent group element
        %
        % Abstract in `replab.FiniteSubgroup`
        %
        % Args:
        %   g (element of `self.parent`): Element to test membership of
        %
        % Returns:
        %   logical: True if this group contains `g` and false otherwise
            b = self.chain.contains(g);
        end
        
        function sub = subgroup(self, generators, order)
        % Constructs a subgroup of the current group from generators
        %
        % Args:
        %   generators (row cell array of elements of this group): List of generators
        %   order (vpi, optional): Subgroup order
        %
        % Returns:
        %   replab.NiceFiniteSubgroup: The subgroup generated by `generators`
            sub = replab.NiceFiniteSubgroup(self, generators, order);
        end
                       
        % Representation construction
        
        function rho = rep(self, field, dimension, images)
        % Constructs a finite dimensional representation of this group
        %
        % Args:
        %   field ({'R', 'C'}): Whether the representation is real (R) or complex (C)
        %   dimension (integer): Representation dimension
        %   images (row cell array of matrices): Orthonormal/unitary images of the group generators
        %
        % Returns:
        %   replab.Rep: The constructed group representation
            rho = replab.RepByImages(self, field, dimension, self.niceMonomorphism, images);
        end

        function rho = permutationRep(self, dimension, permutations)
        % Constructs a permutation representation of this group
        %
        % The returned representation is real. Use ``rep.complexification``
        % to obtain a complex representation.
        %
        % Args:
        %   dimension: Dimension of the representation
        %   permutations (row cell array of permutations): Images of the generators as permutations of size "dimension"
        %
        % Returns:
        %   replab.Rep: The constructed group representation
            S = replab.Permutations(dimension);
            f = @(g) S.toMatrix(g);
            images = cellfun(f, permutations, 'uniform', 0);
            rho = self.rep('R', dimension, images);
        end

        function rho = signedPermutationRep(self, dimension, signedPermutations)
        % Returns a real signed permutation representation of this group
        %
        % The returned representation is real. Use ``rep.complexification``
        % to obtain a complex representation.
        %
        % Args:
        %   dimension: Dimension of the representation
        %   signedPermutations (row cell array of signed permutations): Images of the generators as signed permutations of size "dimension"
        %
        % Returns:
        %   replab.Rep: The constructed group representation
            S = replab.SignedPermutations(dimension);
            f = @(g) S.toMatrix(g);
            images = cellfun(f, signedPermutations, 'uniform', 0);
            rho = self.rep('R', dimension, images);
        end

    end

end
